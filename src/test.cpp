#include <iostream>
#include <eigen3/Eigen/Dense>
#include <string>
#include "opencv2/opencv.hpp"
#include "opencv2/core/ocl.hpp"
#include "opencv2/objdetect.hpp"
#include <cmath>

using namespace std;
using Eigen::MatrixXd;
using Eigen::VectorXd;
using namespace cv;

// predicton
void prediction(VectorXd& xkk_1, MatrixXd& Pkk_1, VectorXd& xkk, MatrixXd& Pkk, MatrixXd F, MatrixXd Q);
// filtering
void correction(VectorXd& xkk_1, MatrixXd& Pkk_1, VectorXd& xkk, MatrixXd& Pkk, MatrixXd H, VectorXd z, MatrixXd R);

// measurement model
vector<Rect> measurement_model(Mat& frame);
vector<Rect> measurement_model(Mat& frame, Mat& fgMaskMOG);

 
// Prediction model for the present state
void prediction(VectorXd& xkk_1, MatrixXd& Pkk_1, VectorXd& xkk, MatrixXd& Pkk, MatrixXd F, MatrixXd Q)     
{
	xkk_1 = F * xkk;
	Pkk_1 = F * Pkk * F.transpose() + Q;
}

// correction model for the present state
void correction(VectorXd& xkk_1, MatrixXd& Pkk_1, VectorXd& xkk, MatrixXd& Pkk, MatrixXd H, VectorXd z, MatrixXd R) 
{
	VectorXd nu = z - H * xkk_1;
	MatrixXd S = H * Pkk_1 * H.transpose() + R;
	MatrixXd W = Pkk_1 * H.transpose() * S.inverse();

	xkk = xkk_1 + W * nu;
	Pkk = (MatrixXd::Identity(Pkk_1.rows(),Pkk_1.cols()) - W * H ) * Pkk;
}   


// measurement model with HOG
vector<Rect> measurement_model(Mat& frame)
{	
	HOGDescriptor hog; 
	Mat gray;
	hog.setSVMDetector(HOGDescriptor::getDefaultPeopleDetector());
	
	vector<Rect> list;
		
	cvtColor(frame, gray, COLOR_BGR2GRAY);
	hog.detectMultiScale(gray, found, 0, Size(2,2), Size(64,64), 0.8, 2, false);

	/*for(unsigned i = 0; i < list.size(); i++) 
	{
		Rect r = list[i];
		rectangle(frame, r.tl(), r.br(), Scalar(0,255,0), 2);
	}
	*/
	return list;
}


// measurement model with BGS
vector<Rect> measurement_model(Mat& frame, Mat& fgMaskMOG) 
{
	vector<Rect> list;
    	Mat kernel = getStructuringElement(MORPH_RECT, Size(3,3));
       
	// Clean foreground from noise
        morphologyEx(fgMaskMOG, fgMaskMOG, MORPH_OPEN, kernel);

        // Find contours
        vector<vector<Point>> contours;
        findContours(fgMaskMOG.clone(), contours, RETR_TREE, CHAIN_APPROX_SIMPLE);

        if (!contours.empty())
        {
            // Get largest contour
            int idx_largest_contour = -1;
            double area_largest_contour = 0.0;

            for (int i = 0; i < contours.size(); ++i)
            {
                double area = contourArea(contours[i]);
                if (area_largest_contour < area)
                {
                    area_largest_contour = area;
                    idx_largest_contour = i;
                }
            }

            if (area_largest_contour > 50)
            {
                list.push_back(boundingRect(contours[idx_largest_contour]));   
            }
        }

	return list;
}


int main(int, char** )
{
	
	//Capture video 
	VideoCapture cap1("CAM1-2.avi");
	VideoCapture cap2("CAM2-3.avi");
	VideoCapture cap3("CAM3-4.avi");
	Mat frame1,frame2,frame3;

	while(true)
	{
		cap1 >> frame1;
		cap2 >> frame2;
		cap3 >> frame3;


		if(frame1.empty())
        	{
            		cout<<"No frame captured from cam 1"<<endl;
            		break;
        	}
		
		if(frame2.empty())
        	{
            		cout<<"No frame captured from cam 2"<<endl;
            		break;
        	}

		if(frame3.empty())
        	{
            		cout<<"No frame captured from cam 3"<<endl;
            		break;
        	}

		vector<Rect> found = measurement_model(frame1);
		for(unsigned i = 0; i < found.size(); i++) 
		{
			// measurement
			Rect r = found[i];
			rectangle(frame1, r.tl(), r.br(), Scalar(0,255,0), 1);
		}

		found = measurement_model(frame2);
		for(unsigned i = 0; i < found.size(); i++) 
		{
			// measurement
			Rect r = found[i];
			rectangle(frame2, r.tl(), r.br(), Scalar(0,255,0), 1);
		}

		found = measurement_model(frame3);
		for(unsigned i = 0; i < found.size(); i++) 
		{
			// measurement
			Rect r = found[i];
			rectangle(frame3, r.tl(), r.br(), Scalar(0,255,0), 1);
		}


		imshow("Camera 1", frame1);
		imshow("Camera 2", frame2);
		imshow("Camera 3", frame3);
		waitKey(1);


	}

	// Background subtraction part
	/*Mat frame1; //current frame
	Mat fgMaskMOG1; //fg mask fg mask generated by MOG method
	
	Mat frame2; //current frame
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG method

	Mat frame3; //current frame
	Mat fgMaskMOG3; //fg mask fg mask generated by MOG method

	//create Background Subtractor objects
	Ptr<BackgroundSubtractor> pMOG1; //MOG Background subtractor
    	pMOG1 = bgsegm::createBackgroundSubtractorMOG(); //MOG approach

	Ptr<BackgroundSubtractor> pMOG2; //MOG Background subtractor
    	pMOG2 = bgsegm::createBackgroundSubtractorMOG(); //MOG approach

	Ptr<BackgroundSubtractor> pMOG3; //MOG Background subtractor
    	pMOG3 = bgsegm::createBackgroundSubtractorMOG(); //MOG approach


	//create the capture object
    	VideoCapture capture1("CAM1-2.avi");
    	if(!capture1.isOpened())
	{
        	//error in opening the video input
        	cerr <<"Unable to open video file "<< endl;
        	exit(EXIT_FAILURE);
    	}

	//create the capture object
    	VideoCapture capture2("CAM2-3.avi");
    	if(!capture2.isOpened())
	{
        	//error in opening the video input
        	cerr <<"Unable to open video file "<< endl;
        	exit(EXIT_FAILURE);
    	}

	//create the capture object
    	VideoCapture capture3("CAM3-4.avi");
    	if(!capture3.isOpened())
	{
        	//error in opening the video input
        	cerr <<"Unable to open video file "<< endl;
        	exit(EXIT_FAILURE);
    	}

	for(;;)
	{
		if(!capture1.read(frame1)) 
		{
            		cerr << "Unable to read next frame." << endl;
            		cerr << "Exiting..." << endl;
            		exit(EXIT_FAILURE);
        	}

		//update the background model
        	pMOG1->apply(frame1, fgMaskMOG1);
		vector<Rect> list = processVideo(frame1, fgMaskMOG1);

		for(size_t i=0; i<list.size(); i++)
		{
			rectangle(frame1, list.at(i), Scalar(0, 255, 0));
		}
		imshow("Camera 2", frame1);

		if(!capture2.read(frame2)) 
		{
            		cerr << "Unable to read next frame." << endl;
            		cerr << "Exiting..." << endl;
            		exit(EXIT_FAILURE);
        	}
		
		//update the background model
        	pMOG2->apply(frame2, fgMaskMOG2);
		list = processVideo(frame2, fgMaskMOG2);

		for(size_t i=0; i<list.size(); i++)
		{
			rectangle(frame2, list.at(i), Scalar(0, 255, 0));
		}
		imshow("Camera 3", frame2);

		if(!capture3.read(frame3)) 
		{
            		cerr << "Unable to read next frame." << endl;
            		cerr << "Exiting..." << endl;
            		exit(EXIT_FAILURE);
        	}
		
		//update the background model
        	pMOG3->apply(frame3, fgMaskMOG3);
		list = processVideo(frame3, fgMaskMOG3);

		for(size_t i=0; i<list.size(); i++)
		{
			rectangle(frame3, list.at(i), Scalar(0, 255, 0));
		}
		imshow("Camera 4", frame3);
		
		
        	if(waitKey(30) >= 0) break;
	}

	*/
	return 0;
}





